---
layout: page
title: Как писать классы по БЭМ?
type: page
permalink: /bem-rules/

links:
 - name: 'Простой пример: Блок + Элемент'
   url: '#block-elem'
 - name: 'Пример посложнее: Блок + Элемент + Модификатор'
   url: '#block-elem-mod'
 - name: 'Ещё сложнее: что делать, если хочется сделать элемент элемента?'
   url: '#elem-elem'
---

  <div class="intro">
    <p><a href="https://ru.bem.info/">БЭМ</a> расшифровывается как «Блок Элемент Модификатор». На самом деле, это целый стэк технологий, из которого мы воспользуемся только <a href="https://ru.bem.info/methodology/naming-convention/">соглашением по именованию классов</a>.</p>

    <p>Почему БЭМ?</p>

    <ul>
      <li>БЭМ позволяет создавать абсолютно независимые блоки. Блоки и элементы получают уникальные имена, так что стили для одного элемента ничего не поломают в другом.</li>
      <li>БЭМ помогает легко придумывать любое количество классов, не повторяющихся между собой.</li>
      <li>БЭМ помогает писать самодокументирующийся код, в классе любого элемента содержится информация о нём.</li>
    </ul>

    <p>Подробнее можно почитать в разделах <a href="https://ru.bem.info/methodology/quick-start/">Быстрый старт</a> и
    <a href="https://ru.bem.info/methodology/faq/">Часто задаваемые вопросы</a> на сайте <a href="https://ru.bem.info/">bem.info</a>.</p>

    <p>Ниже показаны примеры кода.</p>
  </div>


    <ol>
      <li>
        <h3 id="block-elem">Простой пример: Блок + Элемент <a class="post__anchor" href="#block-elem">#</a></h3>

        <p>Допустим, у вас есть блок с заголовком, текстом и кнопкой внутри, например, это всплывающее окно — попап. Разметка:</p>

{% highlight html %}
<div>
  <h3>Заголовок</h3>
  <div>Текст</div>
  <button>Кнопка</button>
</div>
{% endhighlight %}

        <p>Добавляем класс содержащий назначение элемента: <code>.popup</code>:</p>

{% highlight html %}
<div class="popup">
  <h3>Заголовок</h3>
  <div>Текст</div>
  <button>Кнопка</button>
</div>
{% endhighlight %}

        <p>Теперь попробуем добавить классы вложенным элементам:</p>

{% highlight html %}
<div class="popup">
  <h3 class="title">Заголовок</h3>
  <div class="text">Текст</div>
  <button class="button">Кнопка</button>
</div>
{% endhighlight %}

        <p>Классы удобные, но не уникальные. Если на странице будут ещё элементы с классами <code>.title</code> и <code>.text</code>, их стили могут затронуть элементы в попапе. Селектор типа <code>.popup .title</code> может в будущем создать проблемы со специфичностью. Можно придумать другие классы, но чем больше похожих по смыслу элементов, тем сложнее придумывать новые классы.</p>

        <p>А теперь применим БЭМ-нотацию: каждому элементу внутри блока добавим префикс с классом родителя, например, для заголовка это будет <code>popup__title</code>: </p>

{% highlight html %}
<div class="popup">
  <h3 class="popup__title">Заголовок</h3>
  <div class="popup__text">Текст</div>
  <button class="popup__button">Кнопка</button>
</div>
{% endhighlight %}

        <p>Теперь эти классы легко решают сразу две задачи: во-первых, благодаря уникальным классам стили для них никогда не пересекутся с другими подобными элементами на странице, а во-вторых, по таким классам сразу видно, что это элементы блока <code>.popup</code>.</p>
      </li>

      <li>
        <h3 id="block-elem-mod">Пример посложнее: Блок + Элемент + Модификатор <a class="post__anchor" href="#block-elem-mod">#</a></h3>

        <p>Для примера возьмём сервисное сообщение на сайте. Обычно такие сообщения бывают разных видов, например, сообщение об успешном завершении действия или об ошибке. </p>

{% highlight html %}
<div class="message">
  <h3 class="message__title">Заголовок сообщения</h3>
  <div class="message__text">Текст сообщения</div>
</div>
{% endhighlight %}

        <p>Логично использовать одну и ту же разметку, но с разными цветовыми темами. Именно здесь очень пригодятся модификаторы.</p>

{% highlight html %}
<div class="message message_success">
  <h3 class="message__title">Заголовок сообщения</h3>
  <div class="message__text">Текст сообщения</div>
</div>

<div class="message message_error">
  <h3 class="message__title">Заголовок сообщения</h3>
  <div class="message__text">Текст сообщения</div>
</div>
{% endhighlight %}

      <p>Обоим элементам можно добавить одинаковые стили используя общий класс <code>.message</code> и так же легко можно добавить отдельные стили для каждого из них, используя уникальный класс с модификатором:</p>

{% highlight css %}

.message {
  border: 1px solid gray;
}
  .message_success {
    border-color: green;
  }

  .message_error {
    border-color: red;
  }

{% endhighlight %}

        <p>Оба сообщения будут иметь рамку толщиной один пиксель, но для сообщения об успешной операции она будет зелёной, а для сообщения об ошибке — красной.</p>
      </li>

      <li>
        <h3 id="elem-elem">Ещё сложнее: что делать, если хочется сделать элемент элемента? <a class="post__anchor" href="#elem-elem">#</a></h3>

        <p>Например, на странице есть блок новостей:</p>

{% highlight html %}
<div class="news">
    <h3>Новости</h3>

    <ul>
      <li><!-- новость --></li>
      <li><!-- новость --></li>
    </ul>
</div>
{% endhighlight %}

        <p>Заголовок блока логично получает класс <code>.news__title</code>, список — <code>.news__list</code>, а отдельная новость — <code>.news__item</code>:</p>

{% highlight html %}
<div class="news">
    <h3 class="news__title">Новости</h3>

    <ul class="news__list">
      <li class="news__item"><!-- новость --></li>
      <li class="news__item"><!-- новость --></li>
    </ul>
</div>
{% endhighlight %}

        <p>Тут никаких проблем возникнуть не должно. Теперь добавим разметку отдельной новости:</p>

{% highlight html %}
<div class="news">
    <h3 class="news__title">Новости</h3>

    <ul class="news__list">
      <li class="news__item">
        <h4>Заголовок новости</h4>
        <p>Текст новости</p>
      </li>
      <li class="news__item"><!-- новость --></li>
    </ul>
</div>
{% endhighlight %}

        <p>Нам нужно добавить класс заголовку новости. Первым делом приходит в голову <code>.news__title</code>, но такой класс уже занят. Предположим, что второй элемент будет не <code>.title</code>, а <code>.subject</code>, тогда в CSS получается такое:</p>

{% highlight css %}
.news__title { ... }
.news__subject { ... }
{% endhighlight %}

        <p>Без дополнительных комментариев будет совершенно невозможно понять какой из них является заголовком всего блока, а какой — отдельной новости. Не пойдёт.</p>

        <p>Следующий вариант — <code>.news__item__title</code>, но в БЭМ нельзя создавать элемент элемента, и это понятно, потому что получается каша. Ещё вариант: <code>.news__item-title</code> — тоже не годится, потому что может быть неочевидным как <code>title</code> соотносится с <code>item</code>. Как же быть?</p>

        <p>Решение простое: на уровне элемента <code>.news__item</code> можно объявить новый блок (например, <code>.news-item</code>), и строить вложенные классы уже от него. Да, это не самостоятельный переиспользуемый блок, здесь объявление блока нужно только для того, чтобы разгрузить селекторы. Что получается:</p>

{% highlight html %}
<div class="news">
    <h3 class="news__title">Новости</h3>

    <ul class="news__list">
      <li class="news__item news-item">
        <h4 class="news-item__title">Заголовок новости</h4>
        <p class="news-item__text">Текст новости</p>
      </li>
      <li class="news__item"><!-- новость --></li>
    </ul>
</div>
{% endhighlight %}

        <p>Проблема решена: нам больше не нужно использовать монструозные классы, при этом класс точно описывает элемент, и в CSS будет сразу понятно какой класс за что отвечает: </p>

{% highlight css %}
.news__title { ... }
.news-item__title { ... }
{% endhighlight %}

        <p>Простой и удобный выход из неудобной ситуации.</p>

      </li>
    </ol>

    <p>Больше примеров разметки <a href="../examples/">можно увидеть здесь</a>.</p>

    <p>Ещё одно хорошее руководство по использованию БЭМ есть <a href="http://nicothin.github.io/idiomatic-pre-CSS/">здесь</a>.</p>
